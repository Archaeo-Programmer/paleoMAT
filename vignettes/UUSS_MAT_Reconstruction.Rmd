---
title: "Upland United States Southwest Pollen-based Climate Reconstruction"
author: "Andrew Gillreath-Brown"
mainfont: Calibri
output:
  html_document:
    code_folding: show
    keep_md: yes
    number_sections: yes
    theme: sandstone
    toc: yes
    toc_depth: 3
    toc_float: yes
  pdf_document:
    toc: yes
    toc_depth: '3'
always_allow_html: yes
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE, results='hide'}

knitr::opts_chunk$set(echo = TRUE,
                      cache = TRUE)

# devtools::install()
# devtools::load_all()
library(paleomat)

```

# Introduction

Pollen data can be used to do paleo-temperature reconstructions. However, this type of modeling can be affected by a lot of different aspects, such as paleoecological processes, chronology, and topographic effects on communities and species. 

However, improvements in these techniques, and the increasing breadth of paleoclimatic proxies available have furthered our understanding of the effects of climate-driven variability on past societies. 

This program allows you to reconstruct the climate for multiple locations across North America (when data are sufficient to do). In the program below, you can download fossil and modern data from the [Neotoma Paleoecology Database](https://www.neotomadb.org/), then compile the data using Williams and Shuman (2008) so that there will be columns of taxa with counts, as well as metadata attached to each of those records/rows. Some data in Neotoma overlaps with what was used by Whitmore et al. (2005) in the North American Modern Pollen Database, which can be obtained from one of two sources [the Laboratory for Paleoclimatology and Climatology](http://www.lpc.uottawa.ca/data/modern/) at the University of Ottawa and [the Williams Paleoecology Lab](http://www.geography.wisc.edu/faculty/williams/lab/Downloads.html) at the University of Wisconsin. However, data from the North American Pollen Database is constantly being uploaded to Neotoma, and in some cases corrections are being made to the data too.

# Get fossil, modern, and coretop pollen data.
```{r function_model, echo = FALSE, cache=TRUE, message=FALSE, warning=FALSE}

# Use gpids to get the United States and Canada (or their geopolitical units) in North America. Then get the datasets for the pollen data from each of the gpids.

# Retrieve the GeoPolitical Units table, which has country, state, and county level names with associated IDs. 
gpids <- 
  neotoma::get_table(table.name='GeoPoliticalUnits')

NAID <-  
  gpids %>%
  dplyr::filter(GeoPoliticalName %in% c('United States', 'Canada', 'Mexico'),
                GeoPoliticalUnit == 'country') %$%
  GeoPoliticalID

# BEGIN TESTING for MP_metadata_counts
# AZID <-  
#   gpids %>%
#   dplyr::filter(GeoPoliticalName %in% c('Arizona'),
#                 GeoPoliticalUnit == 'state') %$%
#   GeoPoliticalID
# 
# if(!file.exists(here::here("vignettes/data/AZ_metadata_counts.rds"))){
#   AZ_metadata_counts <- 
#   get_modern_pollen(gpid = AZID) %T>%
#   readr::write_rds(here::here("vignettes/data/AZ_metadata_counts.rds"))
# }
# AZ_metadata_counts <- 
#   readr::read_rds(here::here("vignettes/data/AZ_metadata_counts.rds"))

# END TESTING.

if(!file.exists(here::here("vignettes/data/MP_metadata_counts.rds"))){
  MP_metadata_counts <- 
    get_modern_pollen(gpid = NAID) %T>%
    readr::write_rds(here::here("vignettes/data/MP_metadata_counts.rds"))
}
MP_metadata_counts <- 
  readr::read_rds(here::here("vignettes/data/MP_metadata_counts.rds"))

if(!file.exists(here::here("vignettes/data/NAfossil_metadata_counts.rds"))){
  NAfossil_metadata_counts <- 
    get_fossil_pollen(gpid = NAID) %T>%
    readr::write_rds(here::here("vignettes/data/NAfossil_metadata_counts.rds"))
}
NAfossil_metadata_counts <- 
  readr::read_rds(here::here("vignettes/data/NAfossil_metadata_counts.rds"))

coreTops <- 
  paleomat::get_coreTops() %>% 
  dplyr::rename(
    dataset.id = DatasetID,
    site.id = SiteID, 
    sample.id = SampleID
  )

```

# Load and cleanup modern data (i.e., pollen, climate, and locations)

## Modern Pollen Data from "Core tops" of the Fossil Pollen Dataset in Neotoma

```{r load_modernPollenFromFossil, echo = FALSE, message=FALSE, warning=FALSE, results='hide'}

CT_metadata_counts <- 
  dplyr::left_join(coreTops,
                   NAfossil_metadata_counts,
                   by  = c("dataset.id", "site.id", "sample.id")) %>% 
  dplyr::mutate(type = "core top") %>% 
  dplyr::arrange(dataset.id)

```

The Neotoma Modern Pollen Database contains `r nrow(MP_counts)` samples, representing `r ncol(MP_counts)` different pollen taxa.

## Combine Core Top and Modern Pollen Data

```{r Combine_CT_MP, echo = FALSE, message=FALSE, warning=FALSE, results='hide'}

# Now the two dataframes can be combined using the function, then sort the rows by dataset.id. The distinct function is used to make sure there is no duplicate data from combining the two dataframes. Then, we convert all NA values to zero.
MPCT_metadata_counts <- 
  dplyr::bind_rows(MP_metadata_counts, CT_metadata_counts) %>%
  dplyr::arrange(dataset.id) %>%
  dplyr::mutate_at(.vars = dplyr::vars(-dataset.id:-pub_year),
                   .funs = tidyr::replace_na,
                   0) %>%
  dplyr::select(dataset.id:pub_year, 
                sort(tidyselect::peek_vars())) %>%
  dplyr::filter(!is.na(long)) %>% 
  sf::st_as_sf(coords = c("long","lat"), crs = 4326)

```

## Remove Coretops data from the fossil pollen dataset
```{r removeCT, echo = FALSE, message=FALSE, warning=FALSE, results='hide'}

NAfossil_metadata_counts <- 
  dplyr::anti_join(NAfossil_metadata_counts, 
                   coreTops, 
                   by = c("dataset.id", "site.id", "sample.id")) %>%
  sf::st_as_sf(coords = c("long","lat"), crs = 4326)

NAfossil_final <-
  NAfossil_metadata_counts %>%
  dplyr::select(sample.id,
                geometry,
                ABIES:XANTHIUM) %>%
  tibble::as_tibble() %>% 
  dplyr::mutate_all(tidyr::replace_na, 0) %>% 
  tidyr::nest(pollen.counts = c(-sample.id, -geometry)) %>%
  sf::st_as_sf() %>%
  dplyr::select(sample.id,
                pollen = pollen.counts)

```

# Load Prism Climate Data

The first step is to get the locations of the Modern Pollen samples. Next, we use a PRISM climate extraction script, which is adapted from [Bocinsky et al. (2016)](https://github.com/bocinsky/Bocinsky_et_al_2016/blob/master/R/Bocinsky_ET_AL_2016_PRISM_EXTRACTOR.R).  

```{r extract_prism_normals, echo = FALSE, warning=FALSE}
# Extract Prism Climate data for modern pollen.
MPCT_climate <-
  MPCT_metadata_counts %>%
  dplyr::select(sample.id) %>%
  extract_prism_normals() %>%
  sf::st_drop_geometry() %>%
  dplyr::left_join(MPCT_metadata_counts) %>%
  dplyr::select(sample.id, 
                prism.normals,
                geometry,
                ABIES:XANTHIUM) %>%
  tidyr::nest(pollen.counts = c(-sample.id, -prism.normals, -geometry)) %>%
  sf::st_as_sf() %>%
  dplyr::select(sample.id, 
                climate = prism.normals,
                pollen = pollen.counts)

# Get the data into the final format used by the palaeoSig and rioja packages
MPCT_final <- 
  MPCT_climate %>%
  dplyr::mutate(
    pollen = 
      purrr::map(pollen,
        function(x){
          x/rowSums(x)
        }),
    climate = 
      purrr::map(climate,
        function(x){
          x %>%
            dplyr::select(month,
                          ppt,
                          gdd) %>%
            tidyr::pivot_longer(ppt:gdd,
                                names_to = "element") %>%
            tidyr::unite("element_month", element, month) %>%
            tidyr::pivot_wider(names_from = element_month,
                               values_from = value)
        })
  )


```

## Checking the calibration data set

Need to change this into a function. **

To test the model, I used the `palaeoSig` package's `randomTF()` function, which tests the models against randomly sorted data. If we get a significance for a climate variable, then we know that the model reconstruction is better than random. The model takes the proportion of variance accounted for by the actual data, and then compares it to the proportion of variance accounted for by the randomized data.

The MAT method is testing whether the modern calibration is able to detect signals in each of the climate parameters. The example here uses the entire North American Modern Pollen Database, rather than a targeted data subset.


### MAT - ten closest

```{r MAT_sigTesting_init, results='asis', echo=FALSE, warning=FALSE}

# For some reason this fails consistently when we try to use the weighted MAT (col=2).
palaeoSig::randomTF(spp = 
                      MPCT_final %>%
                      dplyr::select(sample.id, pollen) %>%
                      sf::st_drop_geometry() %>%
                      tidyr::unnest(cols = c(pollen)) %>%
                      tibble::column_to_rownames("sample.id"),
                    env = 
                      MPCT_final %>%
                      dplyr::select(sample.id, climate) %>%
                      sf::st_drop_geometry() %>%
                      tidyr::unnest(cols = c(climate)) %>%
                      tibble::column_to_rownames("sample.id"),
                    fos = 
                      MPCT_final %>%
                      dplyr::select(sample.id, pollen) %>%
                      sf::st_drop_geometry() %>%
                      tidyr::unnest(cols = c(pollen)) %>%
                      tibble::column_to_rownames("sample.id"),
                    n = 99,
                    fun = rioja::MAT,
                    col = 1,
                    k = 10) %$%
  tibble::tibble("variable" = colnames(MPCT_final$climate[[1]]),
                 "% Explained" = EX*100,
                 "p-value" = sig)

```

The variance explained is very low for some variables, although the p value is very low. This highlights that in some cases you may not just want to rely on the p value. This also shows the issue with temporal autocorrelation on temperature and, to some extent also, on precipitation variables.

# Reconstruction Statistics

## Reconstruction Significance

Now we can do a similar test on fossil assemblage reconstructions. This again uses the same `randomTF()` function, but the variance explained and significance will probably change given that we are using a slightly more constrained dataset.

Now, we apply a reconstruction to a real dataset.

#### MAT - ten closest

```{r MAT_sigTesting_fossil, cache=TRUE, results='asis', echo=FALSE, warning=FALSE}

palaeoSig::randomTF(spp = 
                      MPCT_final %>%
                      dplyr::select(sample.id, pollen) %>%
                      sf::st_drop_geometry() %>%
                      tidyr::unnest(cols = c(pollen)) %>%
                      tibble::column_to_rownames("sample.id"),
                    env = 
                      MPCT_final %>%
                      dplyr::select(sample.id, climate) %>%
                      sf::st_drop_geometry() %>%
                      tidyr::unnest(cols = c(climate)) %>%
                      tibble::column_to_rownames("sample.id"),
                    fos = 
                      MPCT_final %>%
                      dplyr::select(sample.id, pollen) %>%
                      sf::st_drop_geometry() %>%
                      tidyr::unnest(cols = c(pollen)) %>%
                      tibble::column_to_rownames("sample.id"),
                    n = 99,
                    fun = rioja::MAT,
                    col = 1,
                    k = 10) %$%
  tibble::tibble("variable" = colnames(MPCT_final[[3]][[1]]),
                 "% Explained" = EX*100,
                 "p-value" = sig)


# Old
# This is an altered wrapper for the randomTF function.
source('../R/sig_test2.R')

MP_counts_noNAs <- MPCT_metadata_counts %>% 
  dplyr::select(-site.id:-pub_year) %>% 
  mutate_all(funs(ifelse(is.na(.), 0, .)))

mat_reconst <- run_tf2(MP_counts_noNAs, fossil = fossil_data, 
                       climate = Clim_noNAs[,13:24],
                       func = MAT, col = 2, k = 10)

mat_reconst[[1]]

# for (i in 1:length(fossil_sites)) {
#   nam <- paste("mat_reconst_", fossil_sites[[i]], sep = "")
#   dat <- run_tf2(pollen = MP_counts_noNAs, fossil = get(fossil_sites[[i]]), 
#                  climate = Temperature,
#                  func = mat, col = 2, k = 10)
#   assign(nam, dat)
# }

```

Again, no significance for the model. This indicates that we are just not able to see a signal within the data, but this is probably due to the calibration dataset being too broad.

## Reconstruction

Once we have validated the methods, we re-run the analyses using MAT.

### Model Summary and saving values to file.

```{r clim_reconst, cache=TRUE, results='asis', echo=FALSE, warning=FALSE}

# This is an altered wrapper for the randomTF function.
source('./R/sig_test2.R')

# Create a list of all the fossil pollen sites to be reconstructed for the continental United States.
fossil_sites <- unique(NAfossil_metadata_counts$dataset.id)

# Now, we carry out the reconstruction for all fossil pollen sites in the continental United States. The reconstructions are in one output file, which has the reconstructed gdd and associated error.

# First, to save time, check to see if the sites have already been reconstructed, if so then this chunk will not run. If you would like to re-run the reconstructions, then simply delete the reconstruction .csv and it will run.

if (!file.exists("./vignettes/data/US_reconst_gdd_7analog.rds")) {
  
  mat_models_temp_7analog <- purrr::map(1:12,
                                        .f = function(j){
                                          rioja::MAT(y = dplyr::bind_rows(MPCT_final$pollen), 
                                                     x = dplyr::bind_rows(MPCT_final$climate)[,paste0("gdd_",j)],
                                                     k = 7, 
                                                     dist.method="sq.chord",
                                                     lean = FALSE)
                                        })
  
  US_reconst_7analog <- mat_models_temp_7analog %>%
    purrr::map(.id = "climate",
               .f = function(the.model){
                 # Create the MAT reconstruction.
                 predict(the.model,
                         newdata = dplyr::bind_rows(NAfossil_final$pollen) %>% 
                           as.data.frame() %>% 
                           set_rownames(NAfossil_final$sample.id),
                         sse = FALSE)
               })
  
  readr::write_rds(US_reconst_7analog, "./vignettes/data/US_reconst_gdd_7analog.rds")
  
} else {
  
  stop("The US reconstruction is already completed. If you would like to re-run the reconstructions, then delete the file from the US directory.")
  
}


```


```{r clim_cleanup, cache=TRUE, results='asis', echo=FALSE, warning=FALSE}

# Put the reconstructed data into a dataframe.
NAfossil_metadata_counts %>%
  dplyr::select(dataset.id:pub_year) %>%
  dplyr::mutate(model = "MAT") %>%
  cbind(
    tibble::tibble(reconst = mat_reconst$fit[,1],
                   err = mat_reconst$SEP[,1])
  )

```
